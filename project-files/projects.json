{
  "data": [
    {
      "title": "JetBot",
      "description": "testing",
      "technologies": [
        "Python",
        "OpenCV"
      ],
      "featured": false,
      "images": [
        "LATTICE.png"
      ],
      "slug": "jet-bot",
      "date": "2021-04-01 00:00:00 +00:00",
      "show": false,
      "headers": [
        "Version 1.0"
      ],
      "texts": [
        "yes"
      ],
      "videos": [
        "None"
      ]
    },
    {
      "title": "Boost Gauge",
      "description": "Designed and implemented a boost gauge for real-time monitoring of turbocharger performance in a car. The system accurately measures and displays manifold pressure, enhancing vehicle diagnostics and performance tuning.",
      "technologies": [
        "SolidWorks",
        "Arduino",
        "PCB"
      ],
      "featured": false,
      "images": [
        "boost-iso.png",
        "boost-pcb.png"
      ],
      "slug": "boost-gauge",
      "date": "2020-02-01 00:00:00 +00:00",
      "show": true,
      "headers": [
        "Version 1.0",
        "Version 2.0"
      ],
      "texts": [
        "The objective of this project was to create an analog boost gauge that would add an additional pressure transducer that would feedback directly into an Arduino-based board. This would allow the Arduino to read and output the necessary signals to the motor and the LEDs. This would later be changed by reading the data off of an existing pressure transducer through the ECU using CANBUS signals and data. The final addition was converting the analog into a more circuit simplistic digital screen which would add more functionality to the overall functionality of the product.",
        "This version of the boost gauge is a complete redesign of the older version aimed to be a lot more high-tech. It will include a 2.8-inch rectangular display and a CANBUS reader to eliminate the pressure transducer. This would make it simpler to install on cars and would make it so that the display could show other information about the car such as engine temperature."
      ],
      "videos": [
        "8uzftkWEe00?si=kN5OM5QkMkxYSAwG"
      ]
    },
    {
      "title": "Control Sims",
      "description": "Explore dynamic systems through simulations like a 1D Bouncing Ball, showcasing collision dynamics and energy transfer, and a Passive Walker, demonstrating natural stability and energy-efficient locomotion. These foundational models highlight principles of physics-based control and motion.",
      "technologies": [
        "Matlab",
        "Python"
      ],
      "featured": false,
      "images": [
        "ball.png",
        "passive-walker.png"
      ],
      "slug": "control-sims",
      "date": "2023-08-01 00:00:00 +00:00",
      "show": true,
      "headers": [
        "Bouncing Ball",
        "Passive Walker"
      ],
      "texts": [
        "This is one of my first simulations that I created just to sort out some of the animation steps and to get and understanding to how I am going to derive some of the equations of motion. In this simulation gravity is the only factor the ball is in a fixed position along the x-axis.",
        "This is a simulation of a passive walker, meaning that it does not use motors but its own momentum and gravity to walk. This simulation involves more complicated equations like Euler Lagrange to get the equations of motion. The equations of motion were derived independently using SymPy."
      ],
      "videos": [
        "VEhgk57g3SQ?si=WuGdwtPU3G6SkyW4",
        "N6v5mA1PW5A?si=oRAAVfsrFzXz5sm_"
      ]
    },
    {
      "title": "Lunar Architecture for Tree Traversal in-service-of Cable Exploration",
      "description": "LATTICE is a cable-based infrastructure that will enable robotic transport into and out of craters on the Moon. LATTICE targets implementation as the Moonâ€™s first scalable robotic infrastructure.",
      "technologies": [
        "Arduino",
        "Machining",
        "C++",
        "RF"
      ],
      "featured": true,
      "images": [
        "LATTICE.png"
      ],
      "slug": "lattice",
      "date": "2022-11-01 00:00:00 +00:00",
      "show": true,
      "headers": [
        "Overview"
      ],
      "texts": [
        "LATTICE, Lunar Architecture for Tree Traversal In service of Cabled Exploration, is a way for rovers to traverse the moon, specifically craters, without getting stuck. This project was a part of the Big Idea Challenge set forth by NASA. LATTICE was chosen to be one of the finalists of the competition and receive 180,000 dollars to make it a reality. I was lucky enough to help produce this concept during the summer and my first term at Caltech."
      ],
      "videos": [
        "i8O0wPSCtjg?si=FBZzaTt9D_XiZAlc"
      ]
    },
    {
      "title": "Motion Planning (RRT and EST)",
      "description": "This project involved an in-depth exploration of motion planning algorithms, focusing on Rapidly-exploring Random Trees (RRT) and Expansive Space Trees (EST). Through simulations and implementation, I gained a deep understanding of how these algorithms solve complex pathfinding problems in high-dimensional spaces. ",
      "technologies": [
        "ROS2",
        "Python"
      ],
      "featured": true,
      "images": [
        "rrt.png",
        "est.png"
      ],
      "slug": "motion-planning",
      "date": "2024-03-01 00:00:00 +00:00",
      "show": true,
      "headers": [
        "Rapidly-exploring Random Trees",
        "Expansive Space Trees"
      ],
      "texts": [
        "In the first part of this project, I developed a rapidly exploring random Trees (RRT) algorithm using Python with Matplotlib and Shapley libraries. To simplify the problem, the algorithm was implemented in a 2D space. I ran experiments to analyze the effects of uniform and goal-directed sampling, comparing the behaviors of each. I did this by adjusting the step size to evaluate its impact on the nodes' density, increasing and decreasing their number. Lastly, I explored the algorithm's behavior when orienting toward the goal only a certain percentage of the time, providing insights into its flexibility and adaptability in different scenarios.",
        "In this part of the project, I developed an Expansive Spaces Tree Planner (EST) algorithm using Python with Matplotlib and Shapley libraries. This algorithm prioritizes exploring less-visited areas of the configuration space and samples based on the density of nodes. This characteristic enables the EST to cover more of the map and increases the chance of discovering the most optimal path. Additionally, I experimented with adjusting the standard deviation of the sampling distribution, which influenced the path heading and resulted in many behavioral patterns during exploration."
      ],
      "videos": [
        "None"
      ]
    },
    {
      "title": "Tripteron",
      "description": "The Tripteron is a 3-axis parallel motion robot, similar in concept to a delta robot, but with all three input motions configured to be parallel to each other. This \"Parallel Axis Tripteron\" design leverages a simplified yet efficient kinematic structure for precise movement.",
      "technologies": [
        "ROS2",
        "Matlab",
        "Wolfram"
      ],
      "featured": false,
      "images": [
        "tripteron-urdf.png",
        "tripteron-math.png"
      ],
      "slug": "tripteron",
      "date": "2023-11-01 00:00:00 +00:00",
      "show": true,
      "headers": [
        "Tripteron Model",
        "Math Implementation"
      ],
      "texts": [
        "For this project, I started by making a URDF model of the robot using Matlab. I only made the URDF of the body even though I can only control the feet of the robot for visualization. In reality, we approach the math in another way.",
        "We approach the math by solving the inverse kinematics of the robot. Since we know where we want the platform of the robot to end up and since the platform is always level this simplifies the problem a lot. We can establish a relationship between slider positions and the platform to get a constant transformation matrix. From there we can manipulate the forward kinematic equations turning them into a system of equations to get the inverse kinematics. And we use these in ROS2 program to simulate the motion. "
      ],
      "videos": [
        "None"
      ]
    },
    {
      "title": "2D Simultaneous Localization and Mapping",
      "description": "testing",
      "technologies": [
        "ROS2",
        "Python"
      ],
      "featured": false,
      "images": [
        "LATTICE.png"
      ],
      "slug": "slam",
      "date": "2024-02-01 00:00:00 +00:00",
      "show": false,
      "headers": [
        "Version 1.0"
      ],
      "texts": [
        "yes"
      ],
      "videos": [
        "None"
      ]
    },
    {
      "title": "Stewards Platform",
      "description": "This project involved designing and implementing a stewards platform powered by Metal Gear Servos, utilizing kinematics and PID control for precise motion control. ",
      "technologies": [
        "Matlab",
        "Simulink",
        "Kinematics",
        "3D Printing"
      ],
      "featured": true,
      "images": [
        "swtp-math.png",
        "swtp-workspace.png",
        "stewards-platform.png"
      ],
      "slug": "stewards-platform",
      "date": "2024-06-01 00:00:00 +00:00",
      "show": true,
      "headers": [
        "Kinematics",
        "Workspace Analysis",
        "Design"
      ],
      "texts": [
        "For this project, I am going to start with the kinematics, which will influence our design approach. I do this in a very similar way to how I did the Tripteron project, in the sense that we know where we want the position of the platform to be, so I start there, get each point attached to the top platform, and solve the inverse kinematics one by one while constraining it to be within the allowed parameters.",
        "I used the equations to go through some ranges to see how much the robot could move and if it was a usable space. I put values from the rough CAD I created to visualize the robot (values are in mm). I then changed the lengths of the legs until I had an acceptable range. (also, for this simulation, the platform would remain horizontal to the floor for simplicity)",
        "Now that the joint geometry was finalized, I started to design the rest of the robot to what was reasonable. At first, I used spherical rod ends, but they provided limited motion because the joint only had about plus or minus 20 degrees of movement. So, I switched to these custom 3D-printed ball joints. The new joints gave me more freedom on where the pivot points would be."
      ],
      "videos": [
        "None"
      ]
    },
    {
      "title": "Pupper: Robot Dog",
      "description": "Developed a quadruped robot heavily inspired by the Stanford model, featuring kinematics, control algorithms, and Python-based simulation and implementation.",
      "technologies": [
        "Python",
        "Control algorithms",
        "Kinematics"
      ],
      "featured": false,
      "images": [
        "pupper.png"
      ],
      "slug": "pupper",
      "date": "2022-05-01 00:00:00 +00:00",
      "show": true,
      "headers": [
        "Version 1.1"
      ],
      "texts": [
        "The pupper project is a quadruped (four-legged robot) developed by Stanford as an introduction to robotics research. Like many others, this project became popular with the rise of the Boston Dynamics Spot.The Pupper base and documentation allowed me to start understanding the intricacies of control systems with something that I knew worked. This also allowed me to reverse engineer the concepts and software used to control a quadruped. The hope is that soon I will be able to add sensors like Lidar and Stereoscopic Vision to make it more like Spot."
      ],
      "videos": [
        "zDLrR8i0gyo?si=paX34dY3x1CD6xjY"
      ]
    },
    {
      "title": "Brinson Weather Balloon",
      "description": "testing",
      "technologies": [
        "SolidWorks",
        "RF"
      ],
      "featured": false,
      "images": [
        "LATTICE.png"
      ],
      "slug": "weather-balloon",
      "date": "2024-08-01 00:00:00 +00:00",
      "show": false,
      "headers": [
        "Version 1.0"
      ],
      "texts": [
        "yes"
      ],
      "videos": [
        "None"
      ]
    },
    {
      "title": "Time-Based Trajectory Optimization",
      "description": "testing",
      "technologies": [
        "Python"
      ],
      "featured": false,
      "images": [
        "LATTICE.png"
      ],
      "slug": "time-trajectory-optimization",
      "date": "2024-04-01 00:00:00 +00:00",
      "show": false,
      "headers": [
        "Version 1.0"
      ],
      "texts": [
        "yes"
      ],
      "videos": [
        "None"
      ]
    }
  ]
}